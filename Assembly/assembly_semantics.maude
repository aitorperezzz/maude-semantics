load assembly_syntax.maude .

mod ASSEMBLY-SEMANTICS is
	protecting ASSEMBLY-SYNTAX .
	
	vars M M' : Memory .
	vars R R' R'' : RegName .
	var b : Bank .
	vars x x' y y' C n : Nat .
	var P P' : Prog .

	*** Defino la evaluacion de un programa en un estado
	sort ProgEval .
	op exec(_,_) : Prog State -> ProgEval .
	



	*** Reescritura de instrucciones
	*** Suma del valor de dos registros y posicionamiento en un tercero
	*** rl [add] : exec( P { C ; ADD R R', R'' } , [ b ; M ; x ; y ; C ] ) => 
	***	exec( P { C ; ADD R R', R'' } , [ b[R'' / ( b[R] + b[R'] )] ; M ; x ; y ; C + 1 ] ) .

	rl [add] : exec( P { C ; ADD R R', R'' } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; ADD R R', R'' } P' , [ b[R'' / ( b[R] + b[R'] )] ; M ; isneg( b[R] + b[R'] ) ; iszero ( b[R] + b[R'] ) ; C + 1 ] ) .

	rl [sub] : exec( P { C ; SUB R R', R'' } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; ADD R R', R'' } P' , [ b[R'' / ( b[R] - b[R'] )] ; M ; x ; y ; C + 1 ] ) .

	rl [addinmed] : exec( P { C ; ADDI R n, R'' } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; ADDI R n, R'' } P' , [ b[R'' / ( b[R] + n )] ; M ; isneg( b[R] + n ) ; iszero( b[R] + n ) ; C + 1 ] ) .
	rl [subinmed] : exec( P { C ; SUBI R n, R'' } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; SUBI R n, R'' } P' , [ b[R'' / ( b[R] - n )] ; M ; isneg( b[R] - n ) ; iszero( b[R] - n ) ; C + 1 ] ) .


	*** Reglas para instrucciones de intercambio registro memoria
	rl [load] : exec( P { C ; LOAD n (R), R' } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; LOAD n (R), R' } P' , [ b[R' /  M[n + b[R] ] ] ; M ; isneg( M[n + b[R] ] ) ; iszero( M[n + b[R] ] ) ; C + 1 ] ) .
	rl [store] : exec( P { C ; STORE R, n (R') } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; STORE R, n (R') } P' , [ b ; M[(n + b[R']) / b[R] ] ; isneg( b[R] ) ; iszero( b[R] ) ; C + 1 ] ) .




	*** Reglas para las instrucciones de salto
	crl [jumpiflesstrue] : exec( P { C ; BL n } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; BL n } P' , [ b ; M ; x ; y ; n ] ) 
		if x == 1 .
	crl [jumpiflessfalse] : exec( P { C ; BL n } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; BL n } P' , [ b ; M ; x ; y ; C + 1 ] ) 
		if x =/= 1  .

	crl [jumpifgreatertrue] : exec( P { C ; BG n } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; BG n } P' , [ b ; M ; x ; y ; n ] ) 
		if x == 0 and y == 0 .
	crl [jumpifgreaterfalse] : exec( P { C ; BG n } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; BG n } P' , [ b ; M ; x ; y ; C + 1 ] ) 
		if not( x == 0 and y == 0 ) .

	crl [jumpifequalertrue] : exec( P { C ; BEQ n } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; BEQ n } P' , [ b ; M ; x ; y ; n ] ) 
		if y == 1 .
	crl [jumpifequalfalse] : exec( P { C ; BEQ n } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; BEQ n } P' , [ b ; M ; x ; y ; C + 1 ] ) 
		if y =/= 1 .

	crl [jumpifdiffertrue] : exec( P { C ; BNE n } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; BNE n } P' , [ b ; M ; x ; y ; n ] ) 
		if y == 0 .
	crl [jumpifdifffalse] : exec( P { C ; BNE n } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; BNE n } P' , [ b ; M ; x ; y ; C + 1 ] ) 
		if y =/= 0 .

	crl [jumpifleqertrue] : exec( P { C ; BLE n } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; BLE n } P' , [ b ; M ; x ; y ; n ] ) 
		if x == 1 or y == 1 .
	crl [jumpifleqfalse] : exec( P { C ; BLE n } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; BLE n } P' , [ b ; M ; x ; y ; C + 1 ] ) 
		if not( x == 1 or y == 1 ) .

	crl [jumpifgeqertrue] : exec( P { C ; BGE n } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; BGE n } P' , [ b ; M ; x ; y ; n ] ) 
		if x == 0 or y == 1 .
	crl [jumpigleqfalse] : exec( P { C ; BGE n } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; BGE n } P' , [ b ; M ; x ; y ; C + 1 ] ) 
		if not( x == 0 or y == 1 ) .

	rl [jump] : exec( P { C ; BR n } P' , [ b ; M ; x ; y ; C ] ) => 
		 exec( P { C ; BR n } P' , [ b ; M ; x ; y ; n ] ) .


	
endm
