fmod IMP-BASICS is

	*** This module defines the basic sorts and syntax.

	protecting QID .
	protecting INT .

	*** Define the types relevant to the language.
	sorts NumVar Object ObjectVar Var .
	subsort Qid < NumVar .
	subsort Qid < Object .
	subsort NumVar < Var .
	subsort ObjectVar < Var .

	*** Define the arithmetic expressions.
	sort AritExp .
	subsort Int < AritExp .
	subsort Var < AritExp .
	op _+_ : AritExp AritExp -> AritExp [ditto] .
	op _-_ : AritExp AritExp -> AritExp [ditto] .
	op _*_ : AritExp AritExp -> AritExp [ditto] .

	*** Define the boolean expressions.
	sort BoolExp .
	ops true false : -> BoolExp [ctor] .
	op _==_ : AritExp AritExp -> BoolExp [comm prec 26] .
	op _!=_ : AritExp AritExp -> BoolExp [comm prec 26] .
	op _leq_ : AritExp AritExp -> BoolExp .
	op _geq_ : AritExp AritExp -> BoolExp .
	op not_ : BoolExp -> BoolExp .
	op _and_ : BoolExp BoolExp -> BoolExp [assoc comm] .
	op _or_ : BoolExp BoolExp -> BoolExp [assoc comm] .

	*** Define the statement type.
	sort Prog .
	op skip : -> Prog [ctor] .
	op _=_ : Var AritExp -> Prog [ctor prec 30] .
	op _;_ : Prog Prog -> Prog [ctor assoc] .
	op if (_) {_} else {_} : BoolExp Prog Prog -> Prog [ctor] .
	op while (_) {_} : BoolExp Prog -> Prog [ctor] .
	op return _ : AritExp -> Prog [ctor] .

endfm

fmod IMP-FUNCTIONS-DEF is
	
	*** This module gives some definitions for the functions.

	protecting IMP-BASICS .

	*** Define what can be used to declare a function, which are variables or objects.
	sorts Input InputList .
	subsort Input < InputList .
	subsort Object < Input .
	subsort NumVar < Input .
	op void : -> Object [ctor] .
	op _,_ : InputList InputList -> InputList [ctor assoc id: void] .

	*** Define a list of what can be passed to a function: an arithmetic expression 
	*** or an object.
	sorts Arg ArgList .
	subsort Arg < ArgList .
	subsort InputList < ArgList .
	subsort AritExp < Arg .
	subsort Object < Arg .
	op _,_ : ArgList ArgList -> ArgList [ditto] .

	*** Define the Func type.
	sorts FuncName Func FuncCall .
	subsort Qid < FuncName .

	*** Specify how to declare a function.
	op function _ (_) {_} : FuncName InputList Prog -> Func [ctor] .
	
	*** There are two ways to call a function: with a return value or without it.
	op _(_) : FuncName ArgList -> AritExp [ctor] .
	op run _(_) : FuncName ArgList -> Prog [ctor] .

	*** Define a list of functions.
	sort FuncList .
	subsort Func < FuncList .
	op NoFunc : -> FuncList [ctor] .
	op __ : FuncList FuncList -> FuncList [ctor assoc comm id: NoFunc] .

endfm

fmod IMP-OBJECTS-DEF is

	*** This module gives some definitions for the objects.

	protecting IMP-FUNCTIONS-DEF .

	sorts Class ClassName .
	subsort Qid < ClassName .

	*** Declare a class.
	op class _ {_} : ClassName FuncList -> Class [ctor] .

	*** A special function in a class is the constructor function.
	op constructor(_) {_} : InputList Prog -> Func [ctor] .

	*** A list of class definitions at the end of a Script.
	sort ClassList .
	subsort Class < ClassList .
	op NoClass : -> ClassList [ctor] .
	op __ : ClassList ClassList -> ClassList [ctor assoc comm id: NoClass] .

	*** Create an object with a defined class.
	op _ = new _ (_) : Object ClassName ArgList -> Prog [ctor] .

	*** Define the object variables.
	op this : -> Object [ctor] .
	op _ . _ : Object NumVar -> ObjectVar [ctor] .

	*** Define the object functions (called methods), which also can be called in 
	*** two different ways.
	op (_ . _)(_) : Object FuncName ArgList -> AritExp [ctor] .
	op run (_ . _)(_) : Object FuncName ArgList -> Prog [ctor] .

	*** Define an object identifier.
	sort ObjectId .
	op [_;_] : Object ClassName -> ObjectId [ctor] .
	op None : -> ObjectId [ctor] .

endfm

fmod IMP-STACK is

	*** This module specifies the Stack, which is a long list of 
	*** variable-value pairs.

	protecting IMP-OBJECTS-DEF .

	var S : Stack .
	vars v v' : NumVar .
	vars N N' : Int .

	sorts StackCell Stack .
	subsort StackCell < Stack .

	op <_,_> : NumVar Int -> StackCell [ctor] .

	op EmptyStack : -> Stack [ctor] .
	op __ : Stack Stack -> Stack [ctor comm assoc id: EmptyStack] .

	*** Change values or add elements to the stack.
	op _[_/_] : Stack NumVar Int -> Stack .
	eq (S < v, N >) [v / N'] = S < v, N' > .
	eq S [v / N] = S < v, N > [owise] .

	*** Access the value of a variable in the stack, if it is there.
	op _[_] : Stack NumVar ~> Int .
	eq (S < v, N >) [v] = N .

endfm

fmod IMP-MEMORY is
	
	*** This module specifies the Memory: first a Stack of main variables followed by a 
	*** Stack for each object defined.

	protecting IMP-STACK .

	vars n n' : Int .
	var c : ClassName .
	vars o o' : Object .
	var v : NumVar .
	var M : Memory .
	var S : Stack .

	sorts Memory .
	***subsort MainMemory < Memory .
	***subsort ClassMemory < Memory .
	***subsort ThisMemory < Memory .
	op NoMemory : -> Memory [ctor] .
	op [main] _ : Stack -> Memory [ctor] .
	***op [ this ; _] _ : ClassName Stack -> ThisMemory [ctor] .
	op __ : ObjectId Stack -> Memory [ctor] .
	op __ : Memory Memory -> Memory [ctor assoc comm id: NoMemory] .
	eq NoMemory = ( [main] EmptyStack ) .

	*** Access elements in memory.
	*** Global variables.
	op _[_] : Memory NumVar ~> Int [ctor] .
	eq (M [main] ( S < v, n > ) ) [v] = n .
	*** Object variables.
	op _[_] : Memory ObjectVar ~> Int [ctor] .
	eq (M [ o ; c ] ( S < v, n > ) ) [ ( o . v ) ] = n .

	*** Change or add elements to memory.
	*** Global variables.
	op _[_/_] : Memory NumVar Int -> Memory [ctor] .
	eq (M ([main] (S < v, n >) ) ) [v / n'] = M ([main] (S < v, n' >) ) .
	eq (M ([main] S) ) [v / n] = M ([main] (S < v, n >) ) [owise] .
	*** Object variables.
	op _[_/_] : Memory ObjectVar Int -> Memory [ctor] .
	eq (M [o ; c] ( S < v, n > ) ) [ ( o . v )  / n'] = M [o ; c] (S < v, n' >) .
	eq (M [o ; c] S) [ o . v / n] = M [o ; c] ( S < v, n > ) [owise] .
	***eq M [ ( this . v ) / n ] = this M [ ( this . v ) / n ] .

	***(
	*** Access elements in memory, specific definitions.
	*** Case of global variables.
	op main _[_] : Memory NumVar ~> Int [ctor] .
	eq main (M [main] ( S < v, N > ) ) [v] = N .
	*** Case of other objects's variables.
	op object _[_] : Memory ObjectVar ~> Int [ctor] .
	eq object (M [ o ; c ] ( S < v, N > ) ) [ ( o . v ) ] = N .
	*** Case of object's own variables.
	***op this _[_] : Memory ObjectVar ~> Int [ctor] .
	***eq this (M [ this ; c ] ( S < v, N > ) ) [ ( this . v ) ] = N .

	*** Change values or add elements to memory, specific definitions.
	*** Case of global variables.
	op main _[_/_] : Memory NumVar Int -> Memory .
	eq main (M [main] (S < v, N >) ) [v / N'] = M ( [main] (S < v, N' > ) ) .
	eq main (M [main] S) [v / N] = M ( [main] ( S < v, N > ) ) [owise] .
	*** Case of other objects' variables.
	op object _[_/_] : Memory ObjectVar Int -> Memory .
	eq object (M [o ; c] ( S < v, N > ) ) [ ( o . v )  / N'] = M [o ; c] (S < v, N' >) .
	eq object (M [o ; c] S) [ o . v / N] = M [o ; c] ( S < v, N > ) [owise] .
	*** Case of object's own variables.
	***op this _[_/_] : Memory ObjectVar Int -> Memory .
	***eq this (M [this ; c] ( S < v, N > ) ) [ ( this . v )  / N'] = M [this ; c] ( S < v, N' > ) .
	***eq this (M [this ; c] S) [ ( this . v ) / N] = M [this ; c] ( S < v, N > ) [owise] .
	)

	*** Pass a memory block for certain object, and change the name if necessary.
	op _[_-_] : Memory Object Object -> Memory [ctor] .
	eq (M ([ o ; c ] S) ) [ o - o' ] = [ o' ; c ] S .
	eq M [ o - o' ] = NoMemory [owise] .

endfm

fmod IMP-FUNCBLOCKS is
	
	*** This module defines the function blocks and gives operators to manipulate them.
	*** The design is similar to Memory.

	protecting IMP-MEMORY .

	var fb : FuncBlock .
	vars o o' : Qid .
	var c : ClassName .
	var fl : FuncList .

	sort FuncBlock .
	op [main] _ : FuncList -> FuncBlock [ctor] .
	op  __ : ObjectId FuncList -> FuncBlock [ctor] .
	op NoFuncBlock : -> FuncBlock [ctor] .
	op __ : FuncBlock FuncBlock -> FuncBlock [ctor assoc comm id: NoFuncBlock] .

	*** Pass the function block of certain object, and change the name if necessary.
	op _[_-_] : FuncBlock Object Object -> FuncBlock [ctor] .
	eq (fb [ o ; c ] fl) [ o - o' ] = [ o' ; c ] fl .
	eq (fb) [ o - o' ] = NoFuncBlock [owise] .

endfm

fmod IMP-SCRIPT is

	*** Define a script and the execution sorts.

	protecting IMP-FUNCBLOCKS .

	*** Define a script.
	sort Script .
	op main{_} : Prog -> Script [ctor] .
	op main{_}_ : Prog FuncList -> Script [ctor] .
	op main{_}_ : Prog ClassList -> Script [ctor] .
	op main{_}__ : Prog FuncList ClassList -> Script [ctor] .

	*** Define an execution.
	sorts Exec AritExec BoolExec .
	subsort AritExp < AritExec .
	subsort BoolExp < BoolExec .
	op exec _ : Script -> Exec [ctor] .
	op <_,_,_,_> : Prog FuncBlock ClassList Memory -> Exec [ctor] .
	op <_,_,_,_> : AritExp FuncBlock ClassList Memory -> AritExec [ctor] .
	op <_,_,_,_> : BoolExp FuncBlock ClassList Memory -> BoolExec [ctor] .

	***(
	*** An object can only be created in the main{} part, so a function execution
	*** will not have a ClassList argument.
	sorts FuncExec FuncAritExec FuncBoolExec .
	op <_,_,_> : Prog FuncBlock Memory -> FuncExec [ctor] .
	op <_,_,_> : AritExp FuncBlock Memory -> FuncAritExec [ctor] .
	op <_,_,_> : BoolExp FuncBlock Memory -> FuncBoolExec [ctor] .
	)

endfm

fmod PRE-EXECUTION is
	
	*** This module specifies how to give a function call a personalized execution:
	*** the personalize operator will give each function call its own memory and function
	*** blocks.

	protecting IMP-SCRIPT .

	var n : Int .
	var v : NumVar .
	var f : FuncName .
	var arl : ArgList .
	vars fb fb' : FuncBlock .
	var fl : FuncList .
	var il : InputList .
	vars P P' : Prog .
	vars cl cl' : ClassList .
	vars M M' : Memory .
	vars o o' : Object .
	var c : ClassName .
	var S : Stack .
	var oi : ObjectId .

	***(
	*** personalize operator can only receive a list with numbers or objects.
	sorts Type TypeList .
	subsort Type < TypeList .
	subsort Int < Type .
	subsort Object < Type .
	***subsort TypeList < ArgList .
	op NoType : -> TypeList [ctor] .
	op _,_ : TypeList TypeList -> TypeList [ctor assoc id: void] .
	)

	op personalize [_;_;_;_,_,_;_] : InputList ArgList ObjectId FuncBlock ClassList Memory Exec -> Exec [ctor] .

	*** Copy all the main functions.
	***(
	eq personalize [ il ; tl ; oi ; fb ([main] (fl)), cl, M ; < P', fb', cl', M' > ] = 
		personalize [ il ; tl ; oi ; fb, cl, M ; < P', fb' ([main] (fl)), cl', M' > ] .
	)
	
	*** Copy all object functions and variables in case an object is passed.	
	eq personalize [ (o', il) ; (o, arl) ; oi ; fb ([ o ; c] fl), cl, M ([ o ; c ] S) ; < P', fb', cl', M' > ] = 
		personalize [ il ; arl ; oi ; fb, cl, M ; < P', fb' ([ o' ; c ] fl), cl', M' ([ o' ; c ] S) > ] .

	*** Set the correct main memory in case a number is passed.
	eq personalize [ (v, il) ; (n, arl) ; oi ; fb, cl, M ; < P', fb', cl', M' > ] = 
		personalize [ il ; arl ; oi ; fb, cl, M ; < P', fb', cl', M'[ v / n ] > ] .

	*** When the input list is empty, add the object's methods and variables in case the 
	*** function was called by an object.
	eq personalize [ void ; void ; [ o ; c ] ; fb ([ o ; c ] fl), cl, M ([ o ; c ] S) ; < P, fb', cl', M' > ] = 
		personalize [ void ; void ; None ; fb, cl, M ; < P, fb' ([ this ; c ] fl), cl', M' ([ this ; c ] S) > ] .

	*** Lastly, return the FuncExec.
	eq personalize [ void ; void ; None ; fb , cl , M ; < P, fb', cl', M' > ] = < P, fb', cl', M' > .

endfm

fmod POST-EXECUTION is

	*** This module specifies how to update objects after a function executes.

	protecting PRE-EXECUTION .


endfm

***(

fmod IMP-GIVEMEMORY is
	
	*** Definition of the giveMemory operator.

	protecting IMP-SCRIPT .

	var n : Int .
	vars P : Prog .
	vars M M' : Memory .
	var v : NumVar .
	vars z z' : Var .
	var oi : ObjectId .
	var o o' : Object .
	var c : ClassName .
	var f : FuncName .
	var i : Input .
	var il : InputList .
	var ar : Arg .
	var arl arl' : ArgList .
	var S : Stack .
	var fb : FuncBlock .
	var cl : ClassList .

	op giveMemory [_____;_/_] : InputList ArgList ObjectId FuncBlock ClassList Memory Memory -> Memory [ctor] .

	*** If an object called the function, add its stack of memory.
	eq giveMemory [ il arl [ o ; c ] fb cl ; ( M ( [ o ; c ] S ) ) / M' ] = 
		giveMemory [ il arl None fb cl ; ( M ( [ o ; c ] S ) ) / ( M' ( [ this ; c ] S ) ) ] .
	
	*** Give memory if the input is a number or an object.
	eq giveMemory [ ( v, il ) ( n, arl ) None fb cl ; M / M' ] = 
		giveMemory [ ( il ) ( arl ) None fb cl ; M / ( M' [ v / n ] ) ] .
	eq giveMemory [ ( o' , il ) ( o , arl ) None fb cl ; (M ( [ o ; c ] S ) ) / M' ] = 
		giveMemory [ (il) (arl) None fb cl ; (M [ o ; c ] S) / (M' ( [ o' ; c ] S ) ) ] .

	
	***eq giveMemory [ void void [ this ; c ] fb cl ; ( M [ this ; c ] S) / M' ] = 
	***	giveMemory [ void void None fb cl ; ( M [ this ; c ] S) / ( M ( [ this ; c ] S ) ) ] .
	
	*** Lastly, when all arguments are parsed, return the final memory
	eq giveMemory [ void void None fb cl ; M / M' ] = M' .
	
endfm

fmod IMP-GIVEFUNCTIONS is
	
	protecting IMP-GIVEMEMORY .

	var n : Int .
	vars q q' : Qid .
	var z : Var .
	vars il il' : InputList .
	var i : Input .
	var ar : Arg .
	vars arl arl' : ArgList .
	var oi : ObjectId .
	vars fb fb' : FuncBlock .
	vars o o' : Object .
	var c : ClassName .
	var fl : FuncList .
	var cl : ClassList .
	var M : Memory .

	op giveFunctions [_____;_/_] : InputList ArgList ObjectId ClassList Memory FuncBlock FuncBlock -> FuncBlock [ctor] .

	*** If it is a method called by an object, give it its own methods as this.
	eq [givefunc-this] : giveFunctions [ il arl [ o ; c ] cl M ; ( fb ( [ o ; c ] fl ) ) / fb' ] =
		giveFunctions [ il arl None cl M ; ( fb ( [ o ; c ] fl ) ) / ( fb' ( [ this ; c ] fl ) ) ] .

	*** For every input passed, ask the funcion block operator to return the function block.
	eq [givefunc-number] : giveFunctions [ ( q', il ) ( n, arl ) None cl M ; fb / fb' ] =
		giveFunctions [ il arl None cl M ; fb / fb' ] .
	eq [givefunc-object] : giveFunctions [ (q', il) (q, arl) None cl M ; fb / fb' ] =
		giveFunctions [ il arl None cl M ; fb / fb' (fb' [ q ; q' ]) ] .

	*** Always pass the main functions and end the process.
	eq [givefunc-main] : giveFunctions [ void void None cl M ; (fb [main] fl) / fb' ] = 
		fb' [main] fl .

	*** End the process.
	***eq [givefunc-final] : giveFunctions [ void void None ; fb / fb' ] = fb' .

endfm

fmod IMP-AFTEREXECUTION is
	
	*** Defines the operators to run after a function executes.

	protecting IMP-PERSONALIZED-EXECUTION .

	var o : Object .
	var c : ClassName .
	vars M M' : Memory .
	vars S S' : Stack .

	*** Has a previous memory and a recently created memory and updates the previous one.
	op afterExecution [_;_/_] : ObjectId Memory Memory -> Memory [ctor] .

	*** If an object called a method, update that object first.
	eq afterExecution [ [ o ; c ] ; (M [ o ; c ] S) / (M' [ this ; c ] S') ] = 
		afterExecution [ None ; (M [ o ; c ] S') / M' ] .
	
	*** Update the rest of the objects involved, recursively.
	eq afterExecution [ None ; (M [ o ; c ] S) / (M' [ o ; c ] S') ] = 
		afterExecution [ None ; (M [ o ; c ] S') / M' ] .

	*** Final step.
	eq afterExecution [ None ; M / NoMemory ] = M .
	eq afterExecution [ None ; M / ( [main] S) ] = M .

endfm


fmod IMP-FUNCTIONCALLS is

	*** Define how memory is given during a function call.

	protecting IMP-SCRIPT .

	*** Give a Memory block for a function execution.
	*** This giveMemory function's last argument is an identifier if the function requesting
	*** memory belings to an object or not.
	op giveMemory [__[_;_]] (_ to _) : VarList AritExpList Object ClassName Memory Memory -> Memory [ctor] .
	op None : -> Object [ctor] .

	eq giveMemory [ vl al [o ; c] ] (M to EmptyMemory) = giveMemory [ vl al [o ; c] ] ([main] EmptyStack [this ; c] EmptyStack) .
	eq giveMemory [ (v, vl) (a, al) M ( [o ; c] ) ] (M') = 
		giveMemory [ vl al M [o ; c] ] (M' [ v / M [a] ]) .
	eq giveMemory [ (v, vl) (o, al) ( M [ o ; c ] S ) ( [o' ; c'] ) ] (M') = 
		giveMemory [ vl al ( M [ o ; c ] S ) ( [o' ; c'] ) ] (M' [ o ; c ] S) .
	eq giveMemory [ (v, vl) (o . v, al) ( M [ o ; c ] S < v, N > ) ( [o' ; c'] ) ] (M') = 
		giveMemory [ vl al ( M [ o ; c ] S < v, N > ) ( [o' ; c'] ) ] (M' [ v / N ]) .
	eq giveMemory [ (v, vl) (this . v, al) ( M [ this ; c ] S < v, N > ) ( [o' ; c'] ) ] (M') = 
		giveMemory [ vl al ( M [ this ; c ] S < v, N > ) ( [o' ; c'] ) ] (M' [ v / N ]) .
	eq giveMemory [ void void M None ] (M') = M' .
	eq giveMemory [ void void (M [o ; c] S) ( [o' ; c'] ) ] (M') = M' [this ; c] S . 


endfm  )








