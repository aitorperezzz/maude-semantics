load imp_syntax.maude .

mod IMP-SEMANTICS is

	*** In this module, the rewrite rules for the IMP language are specified.

	protecting IMP-SYNTAX .
	protecting MEMORY .

	sorts Result AritResult BoolResult .
	subsort AritExp < AritResult .
	subsort BoolExp < BoolResult .
	op <_,_> : Prog Memory -> Result [ctor] .
	op <_,_> : AritExp Memory -> AritResult [ctor] .
	op <_,_> : BoolExp Memory -> BoolResult [ctor] .

	vars N M : Int .
	vars b b' : BoolExp .
	vars sigma sigma' sigma'' : Memory .
	vars v v' : Var .
	vars A B : AritExp .
	vars P P' : Prog .

	*** The evaluation of a number on a certain state of memory is that same number
	rl [numbers] :  < N, sigma > => N .

	*** The evaluation of a variable in a certain state of memory is the value
	*** associated to the variable in that memory
	rl [variables] : < v, sigma > => sigma [v] .


	*** Evaluation of arithmetic expressions
	crl [arit-sum] : < A + B, sigma > => N + M
		if < A, sigma > => N /\ < B, sigma > => M .

	crl [arit-sub] : < A - B, sigma > => N - M
		if < A, sigma > => N /\ < B, sigma > => M .

	crl [arit-prod] : < A * B, sigma > => N * M
		if < A, sigma > => N /\ < B, sigma > => M .


	*** Evaluation of boolean expressions
	rl [true] : < true, sigma > => true .
	rl [false] : < false, sigma > => false .

	crl [bool-equal-true] : < A = B, sigma > => < true, sigma >
		if < A, sigma > => N /\ < B, sigma > => N .
	crl [bool-equal-false] : < A = B, sigma > => < false, sigma >
		if < A, sigma > => M /\  < B, sigma > => N /\ M =/= N .
	crl [bool-diff-true] : < A != B, sigma > => < true, sigma >
		if < A = B, sigma > => < false, sigma > .
	crl [bool-diff-false] : < A != B, sigma > => < false, sigma > 
		if < A = B, sigma > => < true, sigma > .

	crl [leq-true] : < A leq B, sigma > => < true, sigma >
		if < A, sigma > => M  /\  < B, sigma > => N /\ M <= N .
	crl [leq-false] : < A leq B, sigma > => < false, sigma >
		if < A, sigma > => M /\ < B, sigma > => N /\ M > N .
	crl [geq-true] : < A geq B, sigma > => < true, sigma >
		if < A, sigma > => M /\ < B, sigma > => N /\ M >= N .
	crl [geq-false] : < A geq B, sigma > => < false, sigma >
		if < A, sigma > => M /\ < B, sigma > => N /\ M < N .

	crl [bool-not-true] : < not b, sigma > => < true, sigma >
		if < b, sigma > => < false, sigma > .
	crl [bool-not-false] : < not b, sigma > => < false, sigma >
		if < b, sigma > => < true, sigma > .

	crl [bool-or-true] : < b or b', sigma > => < true, sigma >
		if < b, sigma > => < true, sigma > /\ < b', sigma > => < true, sigma > .
	crl [bool-or-true] : < b or b', sigma > => < true, sigma >
		if < b, sigma > => < true, sigma > /\ < b', sigma > => < false, sigma > .
	crl [bool-or-true] : < b or b', sigma > => < true, sigma >
		if < b, sigma > => < false, sigma > /\ < b', sigma > => < true, sigma > .
	crl [bool-or-false] : < b or b', sigma > => < false, sigma >
		if < b, sigma > => < false, sigma > /\ < b', sigma > => < false, sigma > .

	crl [bool-and-true] : < b and b', sigma > => < true, sigma >
		if < b, sigma > => < true, sigma > /\ < b', sigma > => < true, sigma > .
	crl [bool-and-false] : < b and b', sigma > => < false, sigma >
		if < b, sigma > => < false, sigma > /\ < b', sigma > => < true, sigma > .
	crl [bool-and-false] : < b and b', sigma > => < false, sigma >
		if < b, sigma > => < true, sigma > /\ < b', sigma > => < false, sigma > .
	crl [bool-and-false] : < b and b', sigma > => < false, sigma >
		if < b, sigma > => < false, sigma > /\ < b', sigma > => < false, sigma > .


	*** Evaluation of programs
	crl [prog-assign] : < v := A, sigma > => < skip, sigma[v / N] >
		if < A, sigma > => N .

	crl [prog-comp] : < P ; P', sigma > => < skip, sigma' >
		if < P, sigma > => < skip, sigma'' > /\
		< P', sigma'' > => < skip, sigma' > .

	crl [prog-if-true] : < if b then P else P', sigma > => < P, sigma >
		if < b, sigma > => < true, sigma > .
	crl [prog-if-false] : < if b then P else P', sigma > => < P', sigma >
		if < b, sigma > => < false, sigma > .

	crl [prog-while-true] : < while b do P, sigma > => < skip, sigma' >
		if < b, sigma > => < true, sigma > /\
		< P ; while b do P, sigma > => < skip, sigma' > .
	crl [prog-while-false] : < while b do P, sigma > => < skip, sigma >
		if < b, sigma > => < false, sigma > .

endm
