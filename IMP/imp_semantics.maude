load imp_syntax.maude .

mod IMP-INITIAL-PARSE is

	*** This module contains the rules for the initial parsing of the user's data.

	protecting IMP-EXECUTION .

	var P : Prog .
	var fl : FuncList .

	*** Transform a user's input into something understandable by the 
	*** semantics of the language.
	rl [exec-nofunctions] : exec ( main {P} ) => < P, NoFunc, NoStack > .
	rl [exec-default] : exec ( main {P} fl ) => < P, fl, NoStack > .

endm


mod IMP-BASIC-SEMANTICS is

	*** This module specifies the basic arithmetic and statement executions.

	protecting IMP-INITIAL-PARSE .

	vars n m : Int .
	var fl : FuncList .
	vars S S' S'' : Stack .
	var v : Var .
	vars A B : AritExp .
	vars b b' : BoolExp .
	vars P P' : Prog .

	*** Evaluation of a number in a certain state of memory.
	rl [numbers] :  < n, fl, S > => n .

	*** Evaluation of a variable in a certain state of memory.
	rl [variables] : < v, fl, S > => S[ v ] .


	*** Evaluation of arithmetic expressions.
	crl [arit-sum] : < A + B, fl, S > => n + m
		if < A, fl, S > => n /\ < B, fl, S > => m .

	crl [arit-sub] : < A - B, fl, S > => n - m
		if < A, fl, S > => n /\ < B, fl, S > => m .

	crl [arit-prod] : < A * B, fl, S > => n * m
		if < A, fl, S > => n /\ < B, fl, S > => m .


	*** Evaluation of boolean expressions
	rl [true] : < true, fl, S > => true .
	rl [false] : < false, fl, S > => false .

	crl [bool-equal-true] : < A == B, fl, S > => < true, fl, S >
		if < A, fl, S > => n /\ < B, fl, S > => n .
	crl [bool-equal-false] : < A == B, fl, S > => < false, fl, S >
		if < A, fl, S > => m /\  < B, fl, S > => n /\ m =/= n .
	crl [bool-diff-true] : < A != B, fl, S > => < true, fl, S >
		if < A == B, fl, S > => < false, fl, S > .
	crl [bool-diff-false] : < A != B, fl, S > => < false, fl, S > 
		if < A == B, fl, S > => < true, fl, S > .

	crl [leq-true] : < A leq B, fl, S > => < true, fl, S >
		if < A, fl, S > => m  /\  < B, fl, S > => n /\ m <= n .
	crl [leq-false] : < A leq B, fl, S > => < false, fl, S >
		if < A, fl, S > => m /\ < B, fl, S > => n /\ m > n .
	crl [geq-true] : < A geq B, fl, S > => < true, fl, S >
		if < A, fl, S > => m /\ < B, fl, S > => n /\ m >= n .
	crl [geq-false] : < A geq B, fl, S > => < false, fl, S >
		if < A, fl, S > => m /\ < B, fl, S > => n /\ m < n .

	crl [bool-not-true] : < not b, fl, S > => < true, fl, S >
		if < b, fl, S > => < false, fl, S > .
	crl [bool-not-false] : < not b, fl, S > => < false, fl, S >
		if < b, fl, S > => < true, fl, S > .

	crl [bool-or-true] : < b or b', fl, S > => < true, fl, S >
		if < b, fl, S > => < true, fl, S > /\ < b', fl, S > => < true, fl, S > .
	crl [bool-or-true] : < b or b', fl, S > => < true, fl, S >
		if < b, fl, S > => < true, fl, S > /\ < b', fl, S > => < false, fl, S > .
	crl [bool-or-true] : < b or b', fl, S > => < true, fl, S >
		if < b, fl, S > => < false, fl, S > /\ < b', fl, S > => < true, fl, S > .
	crl [bool-or-false] : < b or b', fl, S > => < false, fl, S >
		if < b, fl, S > => < false, fl, S > /\ < b', fl, S > => < false, fl, S > .

	crl [bool-and-true] : < b and b', fl, S > => < true, fl, S >
		if < b, fl, S > => < true, fl, S > /\ < b', fl, S > => < true, fl, S > .
	crl [bool-and-false] : < b and b', fl, S > => < false, fl, S >
		if < b, fl, S > => < false, fl, S > /\ < b', fl, S > => < true, fl, S > .
	crl [bool-and-false] : < b and b', fl, S > => < false, fl, S >
		if < b, fl, S > => < true, fl, S > /\ < b', fl, S > => < false, fl, S > .
	crl [bool-and-false] : < b and b', fl, S > => < false, fl, S >
		if < b, fl, S > => < false, fl, S > /\ < b', fl, S > => < false, fl, S > .


	*** Evaluation of programs
	crl [prog-assign] : < v = A, fl, S > => < skip, fl, S [v / n] >
		if < A, fl, S > => n .

	crl [prog-comp] : < P ; P', fl, S > => < skip, fl, S' >
		if < P, fl, S > => < skip, fl, S'' > /\
		< P', fl, S'' > => < skip, fl, S' > .

	crl [prog-if-true] : < if (b) {P} else {P'}, fl, S > => < P, fl, S >
		if < b, fl, S > => < true, fl, S > .
	crl [prog-if-false] : < if (b) {P} else {P'}, fl, S > => < P', fl, S >
		if < b, fl, S > => < false, fl, S > .

	crl [prog-while-true] : < while (b) {P}, fl, S > => < skip, fl, S' >
		if < b, fl, S > => < true, fl, S > /\
		< P ; while (b) {P}, fl, S > => < skip, fl, S' > .
	crl [prog-while-false] : < while (b) {P}, fl, S > => < skip, fl, S >
		if < b, fl, S > => < false, fl, S > .

endm

mod IMP-FUNCTIONS-SEMANTICS is
	
	*** Specifies the semantics of function calls.

	protecting IMP-BASIC-SEMANTICS .

	var n : Int .
	vars fl fl' : FuncList .
	vars S S' S'' : Stack .
	var P : Prog .
	var v : Var .
	var f : FuncName .
	var vl : VarList .
	var a : AritExp .
	vars al al' : AritExpList .

	*** Semantics of the giveStack operation.
	crl giveStack [ (v, vl) (a, al) ; fl ; S ] => < v, n > giveStack [ vl al ; fl ; S ] if 
		< a, fl, S > => n .

	***(
	*** If one of the arguments passed to a function is an arithmetic expression, 
	*** first evaluate it.
	crl [function-arit] : < f (al, a, al'), fl function f ( vl ) { P }, S > => 
		< f (al, n, al'), fl function f ( vl ) { P }, S > 
		if < a, fl function f ( vl ) { P }, S > => n .

	)

	*** Semantics of the return operation.
	crl [return] : < return a, fl, S > => < skip, fl, S[ 'return / n ] > if 
		< a, fl, S > => n .

	*** Give a personalised stack to a function call.
	crl [function-givestack] : < f ( al ), fl function f (vl) {P}, S > => S''[ 'return ] if 
		giveStack [ vl al ; fl function f (vl) {P} ; S ] => S' /\ 
		< P, fl function f (vl) {P}, S' > => 
		< skip, fl function f (vl) {P}, S'' > .

endm
