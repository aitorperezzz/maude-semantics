load imp_defs.maude .

mod IMP-INITIALPARSE is
	
	*** Define the initial parsing rules.

	protecting PRE-EXECUTION .

	***var t : Script .
	vars P P' : Prog .
	var f : FuncName .
	var il : InputList .
	vars fl fl' : FuncList .
	vars cl cl' : ClassList .
	var M : Memory .
	var fb : FuncBlock .
	var c : ClassName .

	op parse [_,_,_] : FuncList ClassList Exec -> Exec [ctor] .

	*** Complete the execution statement in case the user has not given all information.
	rl [exec-nofunc] : exec ( main {P} ( cl ) ) => exec ( main {P} NoFunc cl ) .
	rl [exec-noclass] : exec ( main {P} fl ) => exec ( main {P} fl NoClass ) .
	rl [exec-nothing] : exec ( main {P} ) => exec ( main {P} NoFunc NoClass ) .

	rl [parse-init] : exec ( main {P} fl cl ) => parse [ fl, cl, < P, [main] ( NoFunc ), NoClass, NoMemory > ] .
	rl [parse-function] : parse [ ( fl function f (il) {P'} ), cl, < P, [main] fl', cl', M > ] => 
		parse [ fl, cl, < P, ( [main] ( fl' function f (il) {P'} ) ), cl', M > ] .
	rl [parse-class] : parse [ fl, ( cl class c {fl'} ), < P, fb, cl', M > ] => 
		parse [ fl, cl, < P, fb, ( cl' class c {fl'} ), M > ] .

	*** Finally, give a semantic execution when thre's no functions or classes left.
	rl [parse-final] : parse [ NoFunc, NoClass, < P, fb, cl, M > ] => < P, fb, cl, M > .

endm

mod IMP-BASIC-SEMANTICS is

	*** In this module, the basic rewrite rules for the IMP language are specified.

	protecting IMP-INITIALPARSE .

	vars n m : Int .
	vars b b' : BoolExp .
	vars M M' M'' : Memory .
	vars z z' : Var .
	vars A B : AritExp .
	vars P P' : Prog .
	var fb : FuncBlock .
	var cl : ClassList .
	var o : Object .

	*** Evaluation of a number.
	rl [numbers] :  < n, fb, cl, M > => n .

	*** Evaluation of a variable.
	rl [var] : < z, fb, cl, M > => M [z] .

	*** Evaluation of arithmetic expressions.
	crl [arit-sum] : < A + B, fb, cl, M > => n + m
		if < A, fb, cl, M > => n /\ < B, fb, cl, M > => m .

	crl [arit-sub] : < A - B, fb, cl, M > => n - m
		if < A, fb, cl, M > => n /\ < B, fb, cl, M > => m .

	crl [arit-prod] : < A * B, fb, cl, M > => n * m
		if < A, fb, cl, M > => n /\ < B, fb, cl, M > => m .


	*** Evaluation of boolean expressions
	rl [true] : < true, fb, cl, M > => true .
	rl [false] : < false, fb, cl, M > => false .

	crl [bool-equal-true] : < A == B, fb, cl, M > => < true, fb, cl, M >
		if < A, fb, cl, M > => m /\ < B, fb, cl, M > => m .
	crl [bool-equal-false] : < A == B, fb, cl, M > => < false, fb, cl, M >
		if < A, fb, cl, M > => m /\  < B, fb, cl, M > => n /\ m =/= n .
	crl [bool-diff-true] : < A != B, fb, cl, M > => < true, fb, cl, M >
		if < A == B, fb, cl, M > => < false, fb, cl, M > .
	crl [bool-diff-false] : < A != B, fb, cl, M > => < false, fb, cl, M > 
		if < A == B, fb, cl, M > => < true, fb, cl, M > .

	crl [leq-true] : < A leq B, fb, cl, M > => < true, fb, cl, M >
		if < A, fb, cl, M > => m  /\  < B, fb, cl, M > => n /\ m <= n .
	crl [leq-false] : < A leq B, fb, cl, M > => < false, fb, cl, M >
		if < A, fb, cl, M > => m /\ < B, fb, cl, M > => n /\ m > n .
	crl [geq-true] : < A geq B, fb, cl, M > => < true, fb, cl, M >
		if < A, fb, cl, M > => m /\ < B, fb, cl, M > => n /\ m >= n .
	crl [geq-false] : < A geq B, fb, cl, M > => < false, fb, cl, M >
		if < A, fb, cl, M > => m /\ < B, fb, cl, M > => n /\ m < n .

	crl [bool-not-true] : < not b, fb, cl, M > => < true, fb, cl, M >
		if < b, fb, cl, M > => < false, fb, cl, M > .
	crl [bool-not-false] : < not b, fb, cl, M > => < false, fb, cl, M >
		if < b, fb, cl, M > => < true, fb, cl, M > .

	crl [bool-or-true] : < b or b', fb, cl, M > => < true, fb, cl, M >
		if < b, fb, cl, M > => < true, fb, cl, M > /\ < b', fb, cl, M > => < true, fb, cl, M > .
	crl [bool-or-true] : < b or b', fb, cl, M > => < true, fb, cl, M >
		if < b, fb, cl, M > => < true, fb, cl, M > /\ < b', fb, cl, M > => < false, fb, cl, M > .
	crl [bool-or-true] : < b or b', fb, cl, M > => < true, fb, cl, M >
		if < b, fb, cl, M > => < false, fb, cl, M > /\ < b', fb, cl, M > => < true, fb, cl, M > .
	crl [bool-or-false] : < b or b', fb, cl, M > => < false, fb, cl, M >
		if < b, fb, cl, M > => < false, fb, cl, M > /\ < b', fb, cl, M > => < false, fb, cl, M > .

	crl [bool-and-true] : < b and b', fb, cl, M > => < true, fb, cl, M >
		if < b, fb, cl, M > => < true, fb, cl, M > /\ < b', fb, cl, M > => < true, fb, cl, M > .
	crl [bool-and-false] : < b and b', fb, cl, M > => < false, fb, cl, M >
		if < b, fb, cl, M > => < false, fb, cl, M > /\ < b', fb, cl, M > => < true, fb, cl, M > .
	crl [bool-and-false] : < b and b', fb, cl, M > => < false, fb, cl, M >
		if < b, fb, cl, M > => < true, fb, cl, M > /\ < b', fb, cl, M > => < false, fb, cl, M > .
	crl [bool-and-false] : < b and b', fb, cl, M > => < false, fb, cl, M >
		if < b, fb, cl, M > => < false, fb, cl, M > /\ < b', fb, cl, M > => < false, fb, cl, M > .


	*** Execution of programs
	crl [prog-assign] : < z = A, fb, cl, M > => < skip, fb, cl, M[z / n] >
		if < A, fb, cl, M > => n .

	crl [prog-comp] : < P ; P', fb, cl, M > => < skip, fb, cl, M' >
		if < P, fb, cl, M > => < skip, fb, cl, M'' > /\
		< P', fb, cl, M'' > => < skip, fb, cl, M' > .

	crl [prog-if-true] : < if (b) {P} else {P'}, fb, cl, M > => < P, fb, cl, M >
		if < b, fb, cl, M > => < true, fb, cl, M > .
	crl [prog-if-false] : < if (b) {P} else {P'}, fb, cl, M > => < P', fb, cl, M >
		if < b, fb, cl, M > => < false, fb, cl, M > .

	crl [prog-while-true] : < while (b) {P}, fb, cl, M > => < skip, fb, cl, M' >
		if < b, fb, cl, M > => < true, fb, cl, M > /\
		< P ; while (b) {P}, fb, cl, M > => < skip, fb, cl, M' > .
	crl [prog-while-false] : < while (b) {P}, fb, cl, M > => < skip, fb, cl, M >
		if < b, fb, cl, M > => < false, fb, cl, M > .

endm


***(
mod IMP-AFTEREXECUTION is
	
	*** After a function is called, if it received any object, its variables have to be updated.

	protecting IMP-GIVEFUNCTIONS .

	var z : Var .
	var il : InputList .
	var ar : Arg .
	var arl : ArgList .
	var oi : ObjectId .
	vars fb fb' : FuncBlock .
	vars o o' : Object .
	var c : ClassName .
	var fl : FuncList .

	*** This operator receives a final memory (after a function is executed) and a previous 
	*** memory and updates the relevant items.
	op afterExecution [___;_/_] : InputList ArgList ObjectId Memory Memory -> Memory [ctor] .

	*** If it received a variable, nothing has to be changed.
	rl [update-vars] : afterExecution [ (v, il) (ar, arl) oi ; M' / M ] => 
		afterExecution [ il arl oi ; M' / M ] .

	*** If it received an object, that object has to be updated.
	rl [update-objects] : afterExecution [ (o, il) (o', arl) oi ; (M' [ o ; c ] S') / (M [ o' ; c] S) ] => 
		afterExecution [ il arl oi ; (M' [ o ; c ] S') / (M [ o' ; c] S') ] .

	*** Update object's variables if an object called its own method.
	rl [update-this] : afterExecution [ void void [ this ; c ] ; (M' [ o ; c ] S') / (M [ o' ; c] S) ] => 
		afterExecution [ il arl oi ; (M' [ o ; c ] S') / (M [ o' ; c] S') ] .

endm 
)

mod IMP-FUNCTIONS-SEMANTICS is
	
	*** Specifies the semantics of function calls.

	protecting IMP-BASIC-SEMANTICS .

	var n : Int .
	vars P P' : Prog .
	vars M M' M'' M''' : Memory .
	var v : NumVar .
	vars z z' : Var .
	var oi : ObjectId .
	var o : Object .
	var c : ClassName .
	var f : FuncName .
	var i : Input .
	var il : InputList .
	var ar : Arg .
	vars arl arl' : ArgList .
	var a : AritExp .
	vars fb fb' : FuncBlock .
	vars cl cl' : ClassList .
	var fl : FuncList .

	*** Semantics of the return operation (only present in functions).
	crl [return] : < return a, fb, cl, M > => < skip, fb, cl, M[ 'return / n ] >
		if < a, fb, cl, M > => n .

	*** Rewrite a function call to a personalize operation, and pass the main functions on the fly.
	crl < f (arl), fb ([main] (fl function f (il) {P})), cl, M > => M'[ 'return ] if 
		personalize [ il ; arl ; None ; fb ([main] (fl function f (il) {P})), cl, M ; < P, ([main] (fl function f (il) {P})), NoClass, NoMemory > ] => 
		< skip, fb', cl', M' > . 
		
	*** Evaluate the arguments inside the personalize operator.
	crl personalize [ (v, il) ; (ar, arl) ; oi ; fb, cl, M ; < P', fb', cl', M' > ] => 
		personalize [ (v, il) ; (n, arl) ; oi ; fb, cl, M ; < P', fb', cl', M' > ] 
		if < ar, fb, cl, M > => n .

	
	***(
	*** Now all arguments have been evaluated, they are numbers or objects, so pass the operators.
	crl [functions-assign] : < z = f ( arl ), fb ( [main] ( fl function f (il) {P} ) ), cl, M > => 
		< skip, fb ( [main] ( fl function f (il) {P} ) ), cl, M[ z / M''[ 'return ] ] > if 
		giveMemory [ ( il ) ( arl ) None fb cl ; M / NoMemory ] => M' /\ 
		giveFunctions [ il arl None cl M ; fb ( [main] ( fl function f (il) {P} ) ) / NoFuncBlock ] => fb' /\ 
		< P, fb', cl, M' > => < skip, fb', cl, M'' > .
	crl [functions-arithmetic] : < f ( arl ), fb ( [main] ( fl function f (il) {P} ) ), cl, M > => n if 
		giveMemory [ ( il ) ( arl ) None fb cl ; M / NoMemory ] => M' /\ 
		giveFunctions [ ( il ) ( arl ) None cl M ; ( fb ( [main] ( fl function f (il) {P} ) ) ) / NoFuncBlock ] => fb' /\ 
		< P, fb', cl, M' > => < skip, fb', cl, M'' > /\ 
		M''[ 'return ] => n .
	

	*** Evaluate if the arguments passed are arithmetic expressions.
	crl giveMemory [ ( v, il ) ( a, arl ) None fb cl ; M / M' ] => 
		giveMemory [ ( v, il ) ( n, arl ) None fb cl ; M / M' ] if 
		< a, fb, cl, M > => n .
	*** Evaluate if the arguments passed are arithmetic expressions.
	crl giveFunctions [ ( v, il ) ( ar, arl ) None cl M ; fb / fb' ] => 
		giveFunctions [ ( v, il ) ( n, arl ) None cl M ; fb / fb' ] if 
		< ar, fb, cl, M > => n .
	

	 
	*** Call the relevant operator during a main function call.
	crl [mainfunction-operators] : < z = f (arl), fb ([main] ( fl function f (il) {P} ) ), cl, M > =>
		< skip, fb ([main] ( fl function f (il) {P} ) ), cl, M[ z / M''['return] ] > if
		giveFunctions [ il arl None ; fb ([main] ( fl function f (il) {P} ) ) / NoFuncBlock ] => fb' /\ 
		giveMemory [ il arl None ; M / NoMemory ] => M' /\ 
		< P, fb', cl, M' > => < skip, fb', cl, M'' > .
	crl [mainfunction-operators] : < z = f (arl), fb ([main] ( fl function f (il) {P} ) ), cl, M > =>
		< skip, fb ([main] ( fl function f (il) {P} ) ), cl, M[ z / M''['return] ] > if
		giveFunctions [ il arl None ; fb ([main] ( fl function f (il) {P} ) ) / NoFuncBlock ] => fb' /\ 
		giveMemory [ il arl None ; M / NoMemory ] => M' /\ 
		< P, fb', cl, M' > => < skip, fb', cl, M'' > .
	)

endm

***(

mod IMP-OBJECTS-SEMANTICS is

	*** This module specifies the semantics of objects.

	protecting IMP-FUNCTIONS-SEMANTICS .

	var n : Int .
	var v : Numvar .
	var o : Object .
	var c : ClassName .
	var il : InputList .
	var arl : ArgList .
	var f : FuncName .
	var M : Memory .
	var P : Prog .
	var S S' : Stack .
	vars fb fb' : FuncBlock .
	vars cl cl' : ClassList .

	*** Declare a new object.
	crl < o = new c (arl), fb, cl class c { constructor(il) {P} fl}, M > => 
		< skip, fb ([ o ; c] fl), cl class c { constructor(il) {P} fl}, M (M' [ this - o ]) > if 
		personalize [ il ; arl ; None ; fb, cl class c { constructor(il) {P} }, M ; < P, NoFuncBlock, NoClass, NoMemory > ] =>
		< skip, fb', cl', M' > .

	*** Access an object's variable.
	***rl < ( o . v ), fb, cl, M > => M [ o . v ] .

	*** Rewrite a function call to a personalize operation, pass the main functions on the fly.
	crl < ( o . f ) (arl), fb ([main] fl) ([ o ; c ] (fl' function f(il){P} )), cl, M > => 
		M'[ 'return ] if 
		personalize [ il arl [ o ; c ] ; fb ([main] fl) ([ o ; c ] (fl' function f(il){P} )), cl, M ; 
			< P, fb ([main] fl) ([ this ; c ] (fl' function f(il){P}) , NoClass, NoMemory > ]  => 
		< skip, fb', cl', M' > .


	
endm


	*** If an object is calling its own function.
	rl < x = this . f (arl), fb, cl, M > => 
		< P, giveFunctions [ il arl [ this ; c ] ; fb ( [ this ; c ] (fl function f (il) {P} ) ) / NoFuncBlock ], 
		cl, giveMemory [ il arl [ this ; c ] ; M / EmptyMemory ] > .

	*** If another object's function is called.
	rl < x = o . f (arl), fb ( [ o ; c ] (fl function f (il) {P} ) ), cl, M > => 
		< P, giveFunctions [ il arl [ o ; c ] ; fb  [ this ; c ] fb ( [ o ; c ] (fl function f (il) {P} ) ) / NoFuncBlock ], 
		cl, giveMemory [ il arl [ o ; c ] ; M / EmptyMemory ] > .

	*** If an object is calling a function, give its variables.
	rl [givemem-this] : giveMemory [ void void [ o ; c ] ; (M [ o ; c ] S) / M' ] => 
		giveMemory [ void void None ; (M [ o ; c ] S) / ( M' [ this ; c] S) ] .


	*** How to run the declaration of a new instance of a class.
	*** First transform an arithmetic expression that comes as arguments to the class initialization.
	crl [class-firsttransform] : < x = new c (al, a, al'), el, mem > => 
		< x = new c (al, N, al'), el, mem > if < a, el, mem > => N .
	*** Once the arguments are transformed to numbers, running the constructor means creating a personalized stack.
	crl [class-onlynumbers] : < x = new c (nl), el class c { constructor (vl) {P} cfl }, mem > =>
		< skip, el class c { constructor (vl) {P} cfl }, mem [ x : c ] S' > if 
		giveStack [ vl nl mem ] => S /\ < P, el, [main] S [ x : c ] EmptyStack > => < skip, el, mem' [ x : c ] S' > .

	*** Assignment of a class variable.
	crl [class-assign] : < z = a, el, mem > => < skip, el, mem [ z / N ] > if 
		< a, el, mem > => N .

	*** Evaluation of a class variable.
	rl [class-eval] : < z, el, mem > => mem [ z ] .

	*** Calling of an object's functions from outside.
	crl [class-func] : < c . f ( al ), el class c (vl) { cfl v = function f ( vl ) {P} }, mem > => < skip, el, mem' > if
		 < P, el class c (vl) { cfl v = function f ( vl ) {P} }, giveStack [ vl al mem ] > => 
		< skip, el class c (vl) { cfl v = function f ( vl ) {P} }, mem' > .

	*** Calling an object's function from the inside.
	crl [class-func] : < c . f ( al ), el class c (vl) { cfl v = function f ( vl ) {P} }, mem > => < skip, el, mem' > if
		 < P, el class c (vl) { cfl v = function f ( vl ) {P} }, giveStack [ vl al mem ] > => 
		< skip, el class c (vl) { cfl v = function f ( vl ) {P} }, mem' > .
	)


