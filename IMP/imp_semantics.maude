load imp_syntax.maude .

mod IMP-BASIC-SEMANTICS is

	*** In this module, the rewrite rules for the IMP language are specified.

	protecting IMP-FUNCTIONS-SYNTAX .

	sorts Execution Result AritResult BoolResult .
	subsort AritExp < AritResult .
	subsort BoolExp < BoolResult .
	op exec_ : Script -> Execution [ctor] .
	op exec_with_ : Script Stack -> Execution [ctor] .
	op <_,_,_> : Prog FuncList Stack -> Execution [ctor] .
	op <_,_,_> : AritExp FuncList Stack -> AritResult [ctor] .
	op <_,_,_> : BoolExp FuncList Stack -> BoolResult [ctor] .

	vars N M : Int .
	vars b b' : BoolExp .
	vars sigma sigma' sigma'' : Stack .
	vars v v' : Var .
	vars A B : AritExp .
	vars P P' : Prog .
	var fl : FuncList .
	var S : Script .

	*** Transform a user's input into something understandable by the 
	*** semantics of the language
	rl [exec-default] : exec S => exec S with EmptyStack .
	rl [exec-nofunctions] : exec main {P} with sigma => < P, EmptyFuncList, sigma > .
	rl [exec-functions] : exec ( main {P} fl ) with sigma => < P, fl, sigma > .
	

	*** The evaluation of a number on a certain state of memory is that same number
	rl [numbers] :  < N, fl, sigma > => N .

	*** The evaluation of a variable in a certain state of memory is the value
	*** associated to the variable in that memory
	rl [variables] : < v, fl, sigma > => sigma [v] .


	*** Evaluation of arithmetic expressions
	crl [arit-sum] : < A + B, fl, sigma > => N + M
		if < A, fl, sigma > => N /\ < B, fl, sigma > => M .

	crl [arit-sub] : < A - B, fl, sigma > => N - M
		if < A, fl, sigma > => N /\ < B, fl, sigma > => M .

	crl [arit-prod] : < A * B, fl, sigma > => N * M
		if < A, fl, sigma > => N /\ < B, fl, sigma > => M .


	*** Evaluation of boolean expressions
	rl [true] : < true, fl, sigma > => true .
	rl [false] : < false, fl, sigma > => false .

	crl [bool-equal-true] : < A == B, fl, sigma > => < true, fl, sigma >
		if < A, fl, sigma > => N /\ < B, fl, sigma > => N .
	crl [bool-equal-false] : < A == B, fl, sigma > => < false, fl, sigma >
		if < A, fl, sigma > => M /\  < B, fl, sigma > => N /\ M =/= N .
	crl [bool-diff-true] : < A != B, fl, sigma > => < true, fl, sigma >
		if < A == B, fl, sigma > => < false, fl, sigma > .
	crl [bool-diff-false] : < A != B, fl, sigma > => < false, fl, sigma > 
		if < A == B, fl, sigma > => < true, fl, sigma > .

	crl [leq-true] : < A leq B, fl, sigma > => < true, fl, sigma >
		if < A, fl, sigma > => M  /\  < B, fl, sigma > => N /\ M <= N .
	crl [leq-false] : < A leq B, fl, sigma > => < false, fl, sigma >
		if < A, fl, sigma > => M /\ < B, fl, sigma > => N /\ M > N .
	crl [geq-true] : < A geq B, fl, sigma > => < true, fl, sigma >
		if < A, fl, sigma > => M /\ < B, fl, sigma > => N /\ M >= N .
	crl [geq-false] : < A geq B, fl, sigma > => < false, fl, sigma >
		if < A, fl, sigma > => M /\ < B, fl, sigma > => N /\ M < N .

	crl [bool-not-true] : < not b, fl, sigma > => < true, fl, sigma >
		if < b, fl, sigma > => < false, fl, sigma > .
	crl [bool-not-false] : < not b, fl, sigma > => < false, fl, sigma >
		if < b, fl, sigma > => < true, fl, sigma > .

	crl [bool-or-true] : < b or b', fl, sigma > => < true, fl, sigma >
		if < b, fl, sigma > => < true, fl, sigma > /\ < b', fl, sigma > => < true, fl, sigma > .
	crl [bool-or-true] : < b or b', fl, sigma > => < true, fl, sigma >
		if < b, fl, sigma > => < true, fl, sigma > /\ < b', fl, sigma > => < false, fl, sigma > .
	crl [bool-or-true] : < b or b', fl, sigma > => < true, fl, sigma >
		if < b, fl, sigma > => < false, fl, sigma > /\ < b', fl, sigma > => < true, fl, sigma > .
	crl [bool-or-false] : < b or b', fl, sigma > => < false, fl, sigma >
		if < b, fl, sigma > => < false, fl, sigma > /\ < b', fl, sigma > => < false, fl, sigma > .

	crl [bool-and-true] : < b and b', fl, sigma > => < true, fl, sigma >
		if < b, fl, sigma > => < true, fl, sigma > /\ < b', fl, sigma > => < true, fl, sigma > .
	crl [bool-and-false] : < b and b', fl, sigma > => < false, fl, sigma >
		if < b, fl, sigma > => < false, fl, sigma > /\ < b', fl, sigma > => < true, fl, sigma > .
	crl [bool-and-false] : < b and b', fl, sigma > => < false, fl, sigma >
		if < b, fl, sigma > => < true, fl, sigma > /\ < b', fl, sigma > => < false, fl, sigma > .
	crl [bool-and-false] : < b and b', fl, sigma > => < false, fl, sigma >
		if < b, fl, sigma > => < false, fl, sigma > /\ < b', fl, sigma > => < false, fl, sigma > .


	*** Evaluation of programs
	crl [prog-assign] : < v = A, fl, sigma > => < skip, fl, sigma[v / N] >
		if < A, fl, sigma > => N .

	crl [prog-comp] : < P ; P', fl, sigma > => < skip, fl, sigma' >
		if < P, fl, sigma > => < skip, fl, sigma'' > /\
		< P', fl, sigma'' > => < skip, fl, sigma' > .

	crl [prog-if-true] : < if b then P else P', fl, sigma > => < P, fl, sigma >
		if < b, fl, sigma > => < true, fl, sigma > .
	crl [prog-if-false] : < if b then P else P', fl, sigma > => < P', fl, sigma >
		if < b, fl, sigma > => < false, fl, sigma > .

	crl [prog-while-true] : < while b do P, fl, sigma > => < skip, fl, sigma' >
		if < b, fl, sigma > => < true, fl, sigma > /\
		< P ; while b do P, fl, sigma > => < skip, fl, sigma' > .
	crl [prog-while-false] : < while b do P, fl, sigma > => < skip, fl, sigma >
		if < b, fl, sigma > => < false, fl, sigma > .

endm

mod IMP-FUNCTIONS-SEMANTICS is
	
	*** Specifies the semantics of function calls.

	protecting IMP-FUNCTIONS-SYNTAX .
	protecting IMP-BASIC-SEMANTICS .

	var N : Int .
	vars fl fl' : FuncList .
	var S : Script .
	vars P : Prog .
	var sigma sigma' : Stack .
	vars z v : Var .
	var f : FuncName .
	var vl : VarList .
	var a : AritExp .
	vars al al' : AritExpList .

	*** Give a personalised stack to a function call.
	crl [function-givestack] : < f ( al ), fl function z = f ( vl ) { P }, sigma > => sigma'[z]  
		if < P, fl function z = f ( vl ) { P }, giveStack [ vl al sigma ] > => 
		< skip, fl function z = f ( vl ) { P }, sigma' > .	

	*** If one of the arguments passed to a function is an arithmetic expression, 
	*** first evaluate it.
	crl [function-arit] : < f (al, a, al'), fl function z = f ( vl ) { P }, sigma > => 
		< f (al, N, al'), fl function z = f ( vl ) { P }, sigma > 
		if < a, fl function z = f ( vl ) { P }, sigma > => N .


endm
