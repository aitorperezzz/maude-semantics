load impf_utils.maude .

mod IMPF-SEMANTICS is
	protecting IMPF-SYNTAX .
	protecting IMPF-MEMORY .
	protecting IMPF-STACK .

	*** In this semantics module we specify how we rewrite the states

	*** There's three types of evaluation: a boolean expression, arithmetic expression or a Script
	*** Main change to IMP, we evaluate a Script type, and a Prog is now a subsort of Script
	
	sorts EvalInit Eval EvalB EvalA .
	subsort Nat < EvalA .
	subsort Bexp < EvalB .
	
	
	op <_,_> : Script Memory -> EvalInit [ctor] .
	op <_,_,_> : Aexp FunList Memory -> EvalA [ctor] .
	op <_,_,_> : Bexp FunList Memory -> EvalB [ctor] .

	subsort Eval < EvalInit .
	op <_,_,_> : Prog FunList Memory -> Eval [ctor] .

	vars N M : Nat .
	vars b b' : Bexp .
	vars sigma sigma' sigma'' : Memory .
	vars v v' z : Var .
	vars A B : Aexp .
	vars P P' : Prog .
	vars fl fl' : FunList .
	var f : FunName .
	vars vs vs' : ArgList .

	*** First we rewrite everything to a Program, evaluated on a list of functions and a Memory
	rl [firstiffunctions] : < fl P , sigma > => < P, fl, sigma > .
	rl [firstnofunctions] : < P , sigma > => < P, EmptyFunList, sigma > .

	
	*** Evaluation of a number in a certain memory state is the number itself 
	rl [numbers] :  < N, fl, sigma > => N .

	*** Evaluation of a variable in a certain memory state is the number asociated with the
	*** variable inside the memory at that moment
	rl [variables] : < v, fl, sigma > => sigma [v] .


	*** Evaluation of arithmetic expressions
	crl [ASum] : < A +. B, fl, sigma > => N + M
		if < A, fl, sigma > => N /\ < B, fl, sigma > => M .

	crl [AProd] : < A *. B, fl, sigma > => N * M 
		if < A, fl, sigma > => N /\ < B, fl, sigma > => M .


	*** Evaluation of boolean expressions
	rl [true] : < T, fl, sigma > => T .
	rl [false] : < F, fl, sigma > => F .

	crl [Bequal] : < A B= B, fl, sigma > => < T, fl, sigma >
		if < A, fl, sigma > => N /\ < B, fl, sigma > => N .
	crl [Bequal] : < A B= B, fl, sigma > => < F, fl, sigma >
		if < A, fl, sigma > => N /\  < B, fl, sigma > => M /\ N =/= M  .

	crl [Blesser] : < A B<= B, fl, sigma > => < T, fl, sigma >
		if < A, fl, sigma > => N  /\  < B, fl, sigma > => M /\ N <= M .
	crl [Bgreater] : < A B<= B, fl, sigma > => < F, fl, sigma > 
		if < A, fl, sigma > => N /\ < B, fl, sigma > => M /\ N > M .

	crl [Bnottrue] : < Bnot b, fl, sigma > => < T, fl, sigma >
		if < b, fl, sigma > => < F, fl, sigma > .
	crl [Bnotfalse] : < Bnot b, fl, sigma > => < F, fl, sigma >
		if < b, fl, sigma > => < T, fl, sigma > . 

	crl [Bortrue] : < b Bor b', fl, sigma > => < T, fl, sigma > 
		if < b, fl, sigma > => < T, fl, sigma > /\ < b', fl, sigma > => < T, fl, sigma > .
	crl [Bortrue] : < b Bor b', fl, sigma > => < T, fl, sigma > 
		if < b, fl, sigma > => < T, fl, sigma > /\ < b', fl, sigma > => < F, fl, sigma > .
	crl [Bortrue] : < b Bor b', fl, sigma > => < T, fl, sigma > 
		if < b, fl, sigma > => < F, fl, sigma > /\ < b', fl, sigma > => < T, fl, sigma > .
	crl [Borfalse] : < b Bor b', fl, sigma > => < F, fl, sigma >
		if < b, fl, sigma > => < F, fl, sigma > /\ < b', fl, sigma > => < F, fl, sigma > .

	crl [Bandtrue] : < b Band b', fl, sigma > => < T, fl, sigma >
		if < b, fl, sigma > => < T, fl, sigma > /\ < b', fl, sigma > => < T, fl, sigma > .
	crl [Bandfalse] : < b Band b', fl, sigma > => < F, fl, sigma >
		if < b, fl, sigma > => < F, fl, sigma > /\ < b', fl, sigma > => < T, fl, sigma > .
	crl [Bandfalse] : < b Band b', fl, sigma > => < F, fl, sigma >
		if < b, fl, sigma > => < T, fl, sigma > /\ < b', fl, sigma > => < F, fl, sigma > .
	crl [Bandfalse] : < b Band b', fl, sigma > => < F, fl, sigma >
		if < b, fl, sigma > => < F, fl, sigma > /\ < b', fl, sigma > => < F, fl, sigma > .

	*** Semantics of statements
	crl [assig] : < v := A, fl, sigma > => < skip, fl, sigma[v / N] >
		if < A, fl, sigma > => N .

	crl [comp] : < P ; P', fl, sigma > => < skip, fl, sigma' >
		if < P, fl, sigma > => < skip, fl, sigma'' > /\
		   < P', fl, sigma'' > => < skip, fl, sigma' > .

	crl [iftrue] : < if b then P else P', fl, sigma > => < P, fl, sigma >
		if < b, fl, sigma > => < T, fl, sigma > .
	crl [iffalse] : < if b then P else P', fl, sigma > => < P', fl, sigma >
		if < b, fl, sigma > => < F, fl, sigma > .

	crl [whiletrue] : < while b do P, fl, sigma > => < skip, fl, sigma' >
		if < b, fl, sigma > => < T, fl, sigma > /\
		   < P ; while b do P, fl, sigma > => < skip, fl, sigma' > .
	crl [whilefalse] : < while b do P, fl, sigma > => < skip, fl, sigma >
		if < b, fl, sigma > => < F, fl, sigma > .


	*** Semantics of function calls
	crl [funcall] : < f (vs), fl function z = f (vs') P endfunction fl', sigma > => sigma'[z]
		if < P, fl function z = f (vs') P endfunction fl', givestack[vs vs' sigma] > => 
		< skip, fl function z = f (vs') P endfunction fl', sigma' > .


endm
