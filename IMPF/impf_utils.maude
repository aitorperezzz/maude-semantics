fmod IMPF-VAR is
	
	*** Variables will be called with a ' followed by some characters, like so: 'result
	protecting QID .

	sort Var .
	subsort Qid < Var .

endfm

fmod IMPF-MEMORY is
	protecting IMPF-VAR .

	sort MemoryCell Memory .
	subsort MemoryCell < Memory .

	*** The memory will be just a set of pairs variable-number. Order does not matter. No memory is also a
	*** memory, from which any script begins

	op <_,_> : Var Nat -> MemoryCell [ctor] .

	op EmptyMem : -> Memory [ctor] .
	op __ : Memory Memory -> Memory [ctor comm assoc id: EmptyMem] .

	var M : Memory .
	vars V V' : Var .
	vars N N' : Nat .

	*** Add elements to memory or replace them
	op _[_/_] : Memory Var Nat -> Memory .
	eq (M < V, N >) [V / N'] = M < V, N' > .
	eq M [V / N] = M < V, N > [owise] .

	*** Access a value in memory by specifying the variable's name
	op _[_] : Memory Var ~> Nat .
	eq (M < V, N >) [V] = N .
endfm


fmod IMPF-SYNTAX is
	protecting IMPF-VAR .

	sorts Aexp Bexp Prog .

	*** Syntax of legal boolean expressions
	ops T F : -> Bexp [ctor] .
	op _B=_ : Aexp Aexp -> Bexp [comm] .
	op _B<=_ : Aexp Aexp -> Bexp .
	op Bnot_ : Bexp -> Bexp .
	op _Band_ : Bexp Bexp -> Bexp [comm] .
	op _Bor_ : Bexp Bexp -> Bexp [comm] .

	*** Syntax of legal arithmetic expressions
	*** Variables and numbers are in themselves arithmetic expressions
	subsort Var < Aexp .
	subsort Nat < Aexp .
	op _+._ : Aexp Aexp -> Aexp [comm prec 28] .
	op _*._ : Aexp Aexp -> Aexp [comm prec 29] .

	*** Syntax of legal statements
	op skip : -> Prog [ctor] .
	op _:=_ : Var Aexp -> Prog [ctor prec 30] .
	op _;_ : Prog Prog -> Prog [ctor assoc] .
	op if_then_else_ : Bexp Prog Prog -> Prog [ctor] .
	op while_do_ : Bexp Prog -> Prog [ctor] .


	*** To specify the syntax of function calls, we first define a list of arguments that a function can
	*** receive. These can be arithmetic expressions or variables
	sorts Arg ArgList .
	subsort Arg < ArgList .
	subsort Aexp < Arg .
	subsort Var < Arg .

	*** self will denote no arguments needed and no arguments passed
	op self : -> ArgList [ctor] .
	op _,_ : ArgList ArgList -> ArgList [ctor assoc id: self] .
	
	*** The name of a function is of type Qid. We specify how to write a function. We can have multiple
	*** functions back to back and then a list of statements, as before
	sorts FunName FunBlock FunList .
	subsort Qid < FunName .
	subsort FunBlock < FunList .
	op function _ = _ (_) _ endfunction : Var FunName ArgList Prog -> FunBlock [ctor] .
	op EmptyFunList : -> FunList [ctor] .
	op __ : FunList FunList -> FunList [ctor assoc id: EmptyFunList] .

	*** A Script is in general what we want to execute. A Script consists of a list of functions and then some
	*** commands of type Prog. A Script without functions is a Prog, which is now a subsort of Script
	sort Script .
	subsort Prog < Script .
	op __ : FunList Prog -> Script [ctor] .

	
	*** We can allow to call a function with its name followed by the arguments. The function can only give
	*** back a number, so a function call will be an arithmetic expression.
	op _(_) : FunName ArgList -> Aexp [ctor prec 27] .


endfm

fmod IMPF-STACK is
	protecting IMPF-MEMORY .
	protecting IMPF-SYNTAX .
	
	vars vs vs' : ArgList .
	var sigma : Memory .
	*** o means outer variable, i means inner variable
	vars xo xi : Var .
	var N : Nat .

	*** givestack is a function that will give a personalized memory state whenever a function is called, in the
	*** sense that the set of statements inside a function will work with a memory state specified by the outer
	*** memory state and the arguments passed to the function when called
	*** givestack is recursive on the number of arguments

	op givestack[___] : ArgList ArgList Memory -> Memory [ctor] .
	eq givestack[ ( xo, vs ) ( xi, vs' ) sigma ] = < xi, sigma[xo] > givestack[ vs vs' sigma ] .
	eq givestack[ ( N, vs ) ( xi, vs' ) sigma ] = < xi, N > givestack[ vs vs' sigma ] .
	eq givestack[ self self sigma] = EmptyMem .

endfm

	
