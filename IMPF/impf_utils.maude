fmod IMPF-VAR is
	
	*** Variables will be called with a ' followed by some characters, like so: 'result
	protecting QID .

	sort Var .
	subsort Qid < Var .

endfm

fmod IMPF-MEMORY is
	protecting IMPF-VAR .
	protecting INT .

	sort MemoryCell Memory .
	subsort MemoryCell < Memory .

	*** The memory will be just a set of pairs variable-number. Order does not matter. No memory is also a
	*** memory, from which any script begins

	op <_,_> : Var Int -> MemoryCell [ctor] .

	op EmptyMem : -> Memory [ctor] .
	op __ : Memory Memory -> Memory [ctor comm assoc id: EmptyMem] .

	var M : Memory .
	vars V V' : Var .
	vars N N' : Int .

	*** Add elements to memory or replace them
	op _[_/_] : Memory Var Nat -> Memory .
	eq (M < V, N >) [V / N'] = M < V, N' > .
	eq M [V / N] = M < V, N > [owise] .

	*** Access a value in memory by specifying the variable's name
	op _[_] : Memory Var ~> Nat .
	eq (M < V, N >) [V] = N .
endfm


fmod IMPF-SYNTAX is
	protecting IMPF-VAR .
	protecting INT .

	sorts Aexp Bexp Prog .

	*** Syntax of legal boolean expressions
	ops T F : -> Bexp [ctor] .
	op _B=_ : Aexp Aexp -> Bexp [comm] .
	op _B<=_ : Aexp Aexp -> Bexp .
	op Bnot_ : Bexp -> Bexp .
	op _Band_ : Bexp Bexp -> Bexp [comm] .
	op _Bor_ : Bexp Bexp -> Bexp [comm] .

	*** Syntax of legal arithmetic expressions
	*** Variables and numbers are in themselves arithmetic expressions
	subsort Var < Aexp .
	subsort Int < Aexp .
	op _+._ : Aexp Aexp -> Aexp [comm prec 29] .
	op _*._ : Aexp Aexp -> Aexp [comm prec 30] .
	op _-._ : Aexp Aexp -> Aexp [comm prec 28] .

	*** Syntax of legal statements
	op skip : -> Prog [ctor] .
	op _:=_ : Var Aexp -> Prog [ctor prec 31] .
	op _;_ : Prog Prog -> Prog [ctor assoc] .
	op if_then_else_ : Bexp Prog Prog -> Prog [ctor] .
	op while_do_ : Bexp Prog -> Prog [ctor] .


	*** To specify the syntax of function calls, we shall allow that, in the definition of the function,
	*** a list of variables be given. However, when the function is called from the main script, its
	*** arguments may be replaced by any list of arithmetic expressions, may they be variables, numbers, or
	*** complex arithmetic expressions
	sort VarList AexpList .
	subsort Var < VarList .
	subsort Aexp < AexpList .
	subsort VarList < AexpList .

	*** self will denote no arguments needed and no arguments passed. To achieve this, we define it as a
	*** VarList, and so also as a AexpList
	op self : -> VarList [ctor] .
	op _,_ : VarList VarList -> VarList [ctor assoc id: self] .
	op _,_ : AexpList AexpList -> AexpList [ctor assoc id: self] .
	
	*** The name of a function is of type Qid. We specify how to write a function. We can have multiple
	*** functions back to back and then a list of statements, as before
	sorts FunName FunBlock FunList .
	subsort Qid < FunName .
	subsort FunBlock < FunList .
	op function _ = _ (_) _ endfunction : Var FunName VarList Prog -> FunBlock [ctor] .
	op EmptyFunList : -> FunList [ctor] .
	op __ : FunList FunList -> FunList [ctor assoc id: EmptyFunList] .

	*** A Script is in general what we want to execute. A Script consists of a list of functions and then some
	*** commands of type Prog. A Script without functions is a Prog, which is now a subsort of Script
	sort Script .
	subsort Prog < Script .
	op __ : FunList Prog -> Script [ctor] .

	
	*** We can allow to call a function with its name followed by the arguments. The function can only give
	*** back a number, so a function call will be an arithmetic expression.
	op _(_) : FunName AexpList -> Aexp [ctor prec 27] .


endfm

fmod IMPF-STACK is
	protecting IMPF-MEMORY .
	protecting IMPF-SYNTAX .
	
	var vo : AexpList .
	var vi : VarList .
	var sigma : Memory .
	*** o means outer variable, i means inner variable
	vars xo xi : Var .
	var N : Int .

	*** givestack is a function that will give a personalized memory state whenever a function is called, in the
	*** sense that the set of statements inside a function will work with a memory state specified by the outer
	*** memory state and the arguments passed to the function when called
	*** givestack is recursive on the number of arguments

	op givestack[___] : AexpList VarList Memory -> Memory [ctor] .
	eq givestack[ ( xo, vo ) ( xi, vi ) sigma ] = < xi, sigma[xo] > givestack[ vo vi sigma ] .
	eq givestack[ ( N, vo ) ( xi, vi ) sigma ] = < xi, N > givestack[ vo vi sigma ] .
	eq givestack[ self self sigma] = EmptyMem .

endfm

	
