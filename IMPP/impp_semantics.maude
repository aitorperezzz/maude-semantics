load impp_syntax.maude .

mod IMPP-SEMANTICS is
	protecting IMPP-SYNTAX .
	protecting IMPP-MEMORY .

	***( En el modulo de semantica especificamos como se reescriben los estados. ) 

	***( Los tipos que definimos ahora son a los que eval√∫a un programa, una expresion
	booleana, o una expresion aritmetica. )
	
	sorts Eval EvalB EvalA .
	subsort Nat < EvalA .
	subsort Bexp < EvalB .
	op <_,_> : Prog Memory -> Eval [ctor] .
	op <_,_> : Aexp Memory -> EvalA [ctor] .
	op <_,_> : Bexp Memory -> EvalB [ctor] .

	vars N M : Nat .
	vars b b' : Bexp .
	vars sigma sigma' sigma'' : Memory .
	vars v v' : Var .
	var p : Var .
	vars A B : Aexp .
	vars P P' : Prog .
	*** Using name p for pointer for clearer notation, but a pointer is just a Var

	*** The evaluation of a number in a certain state of the memory is the number itself 
	rl [numbers] :  < N, sigma > => N .

	*** The evaluation of a variable in a state of memory is the value that the memory
	*** location is keeping at that moment
	rl [variables] : < v, sigma > => valuev sigma [v] .

	*** Evaluar expresiones artimeticas 
	crl [ASum] : < A +. B, sigma > => N + M
		if < A, sigma > => N /\ < B, sigma > => M .

	crl [AProd] : < A *. B, sigma > => N * M 
		if < A, sigma > => N /\ < B, sigma > => M .

	*** Evaluar expresiones booleanas 
	rl [true] : < T, sigma > => T .
	rl [false] : < F, sigma > => F .

	crl [Bequal] : < A B= B, sigma > => < T, sigma >
		if < A, sigma > => N /\ < B, sigma > => N .
	crl [Bequal] : < A B= B, sigma > => < F, sigma >
		if < A, sigma > => N /\  < B, sigma > => M /\ N =/= M  .

	crl [Blesser] : < A B<= B, sigma > => < T, sigma >
		if < A, sigma > => N  /\  < B, sigma > => M /\ N <= M .
	crl [Bgreater] : < A B<= B, sigma > => < F, sigma > 
		if < A, sigma > => N /\ < B, sigma > => M /\ N > M .

	crl [Bnottrue] : < Bnot b, sigma > => < T, sigma >
		if < b, sigma > => < F, sigma > .
	crl [Bnotfalse] : < Bnot b, sigma > => < F, sigma >
		if < b, sigma > => < T, sigma > . 

	crl [Bortrue] : < b Bor b', sigma > => < T, sigma > 
		if < b, sigma > => < T, sigma > /\ < b', sigma > => < T, sigma > .
	crl [Bortrue] : < b Bor b', sigma > => < T, sigma > 
		if < b, sigma > => < T, sigma > /\ < b', sigma > => < F, sigma > .
	crl [Bortrue] : < b Bor b', sigma > => < T, sigma > 
		if < b, sigma > => < F, sigma > /\ < b', sigma > => < T, sigma > .
	crl [Borfalse] : < b Bor b', sigma > => < F, sigma >
		if < b, sigma > => < F, sigma > /\ < b', sigma > => < F, sigma > .

	crl [Bandtrue] : < b Band b', sigma > => < T, sigma >
		if < b, sigma > => < T, sigma > /\ < b', sigma > => < T, sigma > .
	crl [Bandfalse] : < b Band b', sigma > => < F, sigma >
		if < b, sigma > => < F, sigma > /\ < b', sigma > => < T, sigma > .
	crl [Bandfalse] : < b Band b', sigma > => < F, sigma >
		if < b, sigma > => < T, sigma > /\ < b', sigma > => < F, sigma > .
	crl [Bandfalse] : < b Band b', sigma > => < F, sigma >
		if < b, sigma > => < F, sigma > /\ < b', sigma > => < F, sigma > .

	*** Evaluar programas
	crl [assig] : < v := A, sigma > => < skip, sigma[v / N] >
		if < A, sigma > => N .

	crl [comp] : < P ; P', sigma > => < skip, sigma' >
		if < P, sigma > => < skip, sigma'' > /\
		   < P', sigma'' > => < skip, sigma' > .

	crl [iftrue] : < if b then P else P', sigma > => < P, sigma >
		if < b, sigma > => < T, sigma > .
	crl [iffalse] : < if b then P else P', sigma > => < P', sigma >
		if < b, sigma > => < F, sigma > .

	crl [whiletrue] : < while b do P, sigma > => < skip, sigma' >
		if < b, sigma > => < T, sigma > /\
		   < P ; while b do P, sigma > => < skip, sigma' > .
	crl [whilefalse] : < while b do P, sigma > => < skip, sigma >
		if < b, sigma > => < F, sigma > .
	

	*** Evaluation of pointer related syntax
	*** Declaration of a pointer
	crl [decpoint] : < ** p := A, sigma > => < skip, sigma [ ( var sigma [ valuev sigma [p] ] ) / N] >
		if < A, sigma > => N .

	*** Meaning of a star and a pointer as an arithmetic expression
	rl [dirtopointer] : < & v, sigma > => adress sigma [v] .
	rl [valuepointer] : < * v, sigma > => valued sigma [valuev sigma [v] ] .


endm
