fmod VAR is
	protecting QID .

	sort Var .
	subsort Qid < Var .

	ops x y z : -> Var [ctor] .
endfm

fmod IMPP-MEMORY is
	protecting VAR .

	sort MemoryCell Memory .
	subsort MemoryCell < Memory .

	*** First element in a memory cell will be the adress, then the variable name, 
	*** then the actual number stored there
	op <_,_,_> : Nat Var Nat -> MemoryCell [ctor] .

	op mt : -> Memory [ctor] .
	op __ : Memory Memory -> Memory [ctor assoc id: mt] .

	vars M M' : Memory .
	vars V V' : Var .
	vars N N' : Nat .
	vars d d' : Nat .

	op _[_/_] : Memory Var Nat -> Memory .
	eq (M < d, V, N > M') [V / N'] = M < d, V, N' > M' .
	eq (M < d, V, N >) [V' / N'] = M < d, V, N > < d + 1, V', N' > [owise] .

	*** Access the memory location of a certain memory cell with the name of the variable
	*** It only works if the variable is already stored in the memory
	op adress _[_] : Memory Var ~> Nat [ctor] .
	eq adress (M < d, V, N >) [V] = d .
	
	*** Acces the value when you know the name of the variable, or the adress
	*** Given the name of a variable
	op valuev _[_] : Memory Var ~> Nat [ctor] .
	eq valuev (M < d, V, N >) [V] = N .
	*** Given the adress of a memory location
	op valued _[_] : Memory Nat ~> Nat [ctor] .
	eq valued (M < d, V, N >) [d] = N .

	*** Access the variable name of a certain location in memory
	op var_[_] : Memory Nat ~> Var [ctor] .
	eq var (M < d, V, N >) [d] = V .


endfm


fmod IMPP-SYNTAX is
	protecting VAR .

	sorts Pointer Aexp Bexp Prog .
	subsort Qid < Pointer .

	*** Syntax of boolean expressions
	ops T F : -> Bexp [ctor] .
	op _B=_ : Aexp Aexp -> Bexp [comm] .
	op _B<=_ : Aexp Aexp -> Bexp .
	op Bnot_ : Bexp -> Bexp .
	op _Band_ : Bexp Bexp -> Bexp [comm] .
	op _Bor_ : Bexp Bexp -> Bexp [comm] .

	*** Sintaxis de expresiones aritmeticas
	subsort Var < Aexp .
	subsort Nat < Aexp .
	op _+._ : Aexp Aexp -> Aexp [comm prec 28] .
	op _*._ : Aexp Aexp -> Aexp [comm prec 29] .

	*** Sintaxis de los programas permitidos
	op skip : -> Prog [ctor] .
	op _:=_ : Var Aexp -> Prog [ctor prec 30] .
	op _;_ : Prog Prog -> Prog [ctor assoc] .
	op if_then_else_ : Bexp Prog Prog -> Prog [ctor] .
	op while_do_ : Bexp Prog -> Prog [ctor] .


	*** Syntax of pointers. A pointer is a variable, so of type Var, and has a memory location
	*** and the value it keeps is an adress to another element in memory.
	
	*** To asign an arithmetic expresion to the element in memory to which the pointer is pointing
	*** know that **(Pointer) is the variable name of the memory location that Pointer is pointing to
	op **_:=_ : Var Aexp -> Prog [ctor] .

	*** Access the value to which the pointer points
	op *_ : Pointer -> Aexp [ctor] .
	
	*** Returns the adress where the variable lives
	op &_ : Var -> Aexp [ctor] .


endfm




